# 이차원 배열 생성과 값 변경
### 문제 상황
미로 생성 코드의 이차원 배열 생성 코드를 수정한 후 값 변경 시 모든 list 의 값이 변경됨

- 정상 코드(퍼온 코드)
~~~python
vis = [[0] * self.w + [1] for _ in range(self.h)] + [[1] * (self.w + 1)]
vis[0][1] = 1
# 값 변경 전
> [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 1]]
# 값 변경 후
> [[0, 1, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 1]]
~~~

- 문제 발생 코드(내가 작성)
~~~python
vis = [[0] * self.w + [1]] * self.h + [[1] * self.w + 1]
vis[0][1] = 1
# 값 변경 전
> [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 1]]
# 값 변경 후 
> [[0, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1], [1, 1, 1, 1]]
~~~

vis[0][1] 이라고 지정했음에도 vis 의 모든 값이 바뀌게되는 문제

### 문제 원인
이차원 배열 생성 시 asterisk(*) 를 사용해서 list 를 생성 했기 때문이다.
정확히 말하자만 생성이 아니라 object 를 reference 한 코드로 동작한다.

for loop 를 사용한 코드는 너무 보기 복잡해서 내 방식으로 코드를 수정해보았다.
하지만 asterisk(*)와 for loop 의 list append 의 차이점을 제대로 인식하지 못했다.

vis[o] = [0, 1, 0, 0]  으로 수정한다면 정상적으로 작동한다. 왜냐하면 vis[0] 의 참조값 자체를 바꿔주었기 때문이다. 현재 vis[0], vis[1], vis[2], vis[3] 은 모두 같은 참조값을 가지는 객체이다. 왜냐하면 asterisk(*)를 통해 값을 복사했기 때문이다.

하지만 list comprehension 의 for loop 를 사용할 경우, data 는 같아도 서로 다른 참조값을 가지는 별개의 객체(vis[0], vis[1], vis[2], vis[3])를 가지게 된다.

### 참고
위 상황은 mutable type object 인 list 이기 떄문에 발생한 문제이다.
immutable type 일 경우 위와 같은 문제가 발생할 수 없다. 당연한 이야기.
